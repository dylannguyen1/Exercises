fc2 <- snaive(train2, h = 4)
fc3 <- snaive(train3, h = 4)
# Use accuracy() to compare the MAPE of each series
accuracy(fc1, vn[, "Melbourne"])["Test set", "MAPE"]
accuracy(fc2, vn[, "Melbourne"])["Test set", "MAPE"]
accuracy(fc3, vn[, "Melbourne"])["Test set", "MAPE"]
vn[, "Melbourne"]
data(vn)
vn
vn[,"Melbourne"]
library(fpp)
data("vn")
vn <-ts(vn)
# Create three training series omitting the last 1, 2, and 3 years
train1 <- window(vn[, "Melbourne"], end = c(2010, 4))
train2 <- window(vn[,"Melbourne"],end = c (2009,4))
train3 <-  window(vn[,"Melbourne"],end = c (2008,4))
# Produce forecasts using snaive()
fc1 <- snaive(train1, h = 4)
fc2 <- snaive(train2, h = 4)
fc3 <- snaive(train3, h = 4)
# Use accuracy() to compare the MAPE of each series
accuracy(fc1, vn[, "Melbourne"])["Test set", "MAPE"]
accuracy(fc2, vn[, "Melbourne"])["Test set", "MAPE"]
accuracy(fc3, vn[, "Melbourne"])["Test set", "MAPE"]
library(fpp)
data("vn")
# Create three training series omitting the last 1, 2, and 3 years
train1 <- window(vn[, "Melbourne"], end = c(2010, 4))
train2 <- window(vn[,"Melbourne"],end = c (2009,4))
train3 <-  window(vn[,"Melbourne"],end = c (2008,4))
# Produce forecasts using snaive()
fc1 <- snaive(train1, h = 4)
fc2 <- snaive(train2, h = 4)
fc3 <- snaive(train3, h = 4)
# Use accuracy() to compare the MAPE of each series
accuracy(fc1, vn[, "Melbourne"])["Test set", "MAPE"]
accuracy(fc2, vn[, "Melbourne"])["Test set", "MAPE"]
accuracy(fc3, vn[, "Melbourne"])["Test set", "MAPE"]
e <- tsCV(oil, forecastfunction  = naive, h =1)
mean(e^2, na.rm= TRUE)
sq <-function(u){u^2} ## square function
for(h in 1:10)
{
oil %>% tsCV(forecastfunction = naive, h =h) %>%
sq() %>% mean(na.rm = TRUE) %>% print()
}
data("goog")
# Compute cross-validated errors for up to 8 steps ahead
e <- tsCV(goog, forecastfunction = naive, h = 8)
# Compute the MSE values and remove missing values
mse <- colMeans(e^2, na.rm = TRUE)
# Plot the MSE values against the forecast horizon
data.frame(h = 1:8, MSE = mse) %>%
ggplot(aes(x = h, y = MSE)) + geom_point()
oildata <- window(oil, start = 1996)
fc <- ses(oildata, h = 5)
summary(fc)
autoplot(fc) +
ylab("Oil(millions of tonnes)") + xlab("Year")
data("marathon")
# Use ses() to forecast the next 10 years of winning times
fc <- ses(marathon, h = 10)
# Use summary() to see the model parameters
summary(fc)
# Use autoplot() to plot the forecasts
autoplot(fc)
# Add the one-step forecasts for the training data to the plot
autoplot(fc) + autolayer(fitted(fc))
AirPassengers %>% holt(h=5) %>% autoplot ## seasonal prediction with holt method
data("AirPassengers")
AirPassengers %>% holt(h=5) %>% autoplot ## seasonal prediction with holt method
AirPassengers %>% holt(h=5) %>% autoplot() ## seasonal prediction with holt method
#
## Exponentially weighted forecasts
#
oildata <- window(oil, start = 1996)
fc <- ses(oildata, h = 5) ## Simple Exponential smoothing 5 years
summary(fc)
autoplot(fc) +
ylab("Oil(millions of tonnes)") + xlab("Year")
#
##
#
data("marathon")
# Use ses() to forecast the next 10 years of winning times
fc <- ses(marathon, h = 10)
# Use summary() to see the model parameters
summary(fc)
# Use autoplot() to plot the forecasts
autoplot(fc)
# Add the one-step forecasts for the training data to the plot
autoplot(fc) + autolayer(fitted(fc))
#
## Simple Exponential smoothing vs naive
#
# Create a training set using subset()
train <- subset(marathon, end = length(marathon) - 20)
# Compute SES and naive forecasts, save to fcses and fcnaive
fcses <- ses(train, h = 20)
fcnaive <- naive(train, h = 20)
# Calculate forecast accuracy measures
accuracy(fcses, marathon)
accuracy(fcnaive, marathon)
# Save the best forecasts as fcbest
fcbest <- fcnaive
#
## Exponential smoothing methods with trend
#
data("AirPassengers")
AirPassengers %>% holt(h=5) %>% autoplot() ## seasonal prediction with holt method
holt(h=5)
#
## Exponentially weighted forecasts
#
oildata <- window(oil, start = 1996)
fc <- ses(oildata, h = 5) ## Simple Exponential smoothing 5 years
summary(fc)
autoplot(fc) +
ylab("Oil(millions of tonnes)") + xlab("Year")
#
##
#
data("marathon")
# Use ses() to forecast the next 10 years of winning times
fc <- ses(marathon, h = 10)
# Use summary() to see the model parameters
summary(fc)
# Use autoplot() to plot the forecasts
autoplot(fc)
# Add the one-step forecasts for the training data to the plot
autoplot(fc) + autolayer(fitted(fc))
#
## Simple Exponential smoothing vs naive
#
# Create a training set using subset()
train <- subset(marathon, end = length(marathon) - 20)
# Compute SES and naive forecasts, save to fcses and fcnaive
fcses <- ses(train, h = 20)
fcnaive <- naive(train, h = 20)
# Calculate forecast accuracy measures
accuracy(fcses, marathon)
accuracy(fcnaive, marathon)
# Save the best forecasts as fcbest
fcbest <- fcnaive
#
## Exponential smoothing methods with trend
#
data("AirPassengers")
AirPassengers %>% holt(h=5) %>% autoplot() ## seasonal prediction with holt method
data(marathon)
library(forecast)
library(fpp2)
library(fpp)
oildata <- window(oil, start = 1996)
fc <- ses(oildata, h = 5) ## Simple Exponential smoothing 5 years
summary(fc)
autoplot(fc) +
ylab("Oil(millions of tonnes)") + xlab("Year")
data("marathon")
# Use ses() to forecast the next 10 years of winning times
fc <- ses(marathon, h = 10)
# Use summary() to see the model parameters
summary(fc)
# Use autoplot() to plot the forecasts
autoplot(fc)
# Add the one-step forecasts for the training data to the plot
autoplot(fc) + autolayer(fitted(fc))
data(marathon)
train <- subset(marathon, end = length(marathon) - 20)
# Compute SES and naive forecasts, save to fcses and fcnaive
fcses <- ses(train, h = 20)
fcnaive <- naive(train, h = 20)
# Calculate forecast accuracy measures
accuracy(fcses, marathon)
accuracy(fcnaive, marathon)
# Save the best forecasts as fcbest
fcbest <- fcnaive
#
## Exponential smoothing methods with trend
#
data("AirPassengers")
AirPassengers %>% holt(h=5) %>% autoplot() ## seasonal prediction with holt method
data("AirPassengers")
AirPassengers %>% holt(h=5) %>% autoplot() ## seasonal prediction with holt method
## Holt and damped trend
fc1 <- holt(AirPassengers, h =15, PI = FALSE) # linear trend
fc2 <- holt(AirPassengers, damped = TRUE, h =15, PI = FALSE) # Damped
autoplot(AirPassengers) + xlab("Year") + ylab("millions")+
autolayer(fc1, series = "Linear Trend") +
autolayer(fc2, series =" Damped trend")
data(austa)
# Produce 10 year forecasts of austa using holt()
fcholt <- holt(austa,h=10)
# Look at fitted model using summary()
summary(fcholt)
# Plot the forecasts
autoplot(fcholt)
# Check that the residuals look like white noise
checkresiduals(fcholt)
aust <- window(austourists, start =2005)
fc1 <- hw(aust, seasonal = "additive")
fc2 <- hw(aust, seasonal = "multiplicative")
aust <- window(austourists, start =2005)
fc1 <- hw(aust, seasonal = "additive")
fc2 <- hw(aust, seasonal = "multiplicative")
autoplot(austourists) + xlab("Year") +ylab("millions of visitors") +
autolayer(fc1, series = "HW additive forecast")+
autolayer(fc2, series = "HW multiplicative forecast")
data(a10)
data("hyndsight")
# Create training data with subset()
train <- subset(hyndsight, end = length(hyndsight)-28)
# Holt-Winters additive forecasts as fchw
fchw <- hw(train, seasonal = "additive", h = 28)
# Seasonal naive forecasts as fcsn
fcsn <- snaive(train, h = 28)
# Find better forecasts with accuracy()
accuracy(fchw, hyndsight)
accuracy(fcsn, hyndsight)
# Plot the better forecasts
autoplot(fchw)
data("ausair")
ausair %>% ets() %>% forecast() %>% autoplot()
data(h02) ## Monthly cortecosteroid drug sales
data(h02) ## Monthly cortecosteroid drug sales
h02 %>% ets() %>% forecast() %>% autoplot()
data(austa)
# Fit ETS model to austa in fitaus
fitaus <- ets(austa)
# Check residuals
checkresiduals(fitaus)
# Plot forecasts
autoplot(forecast(fitaus))
data("hyndsight")
# Repeat for hyndsight data in fiths
fiths <- ets(hyndsight)
checkresiduals(fiths)
autoplot(forecast(fiths))
# Which model(s) fails test? (TRUE or FALSE)
fitausfail <- FALSE
fithsfail <- TRUE
data(cement)
cement %>% ets()
ets(cement)
cement <ts(cement)
cement <- ts(cement)
ets(cement)
plot(cement)
data(cement)
# Function to return ETS forecasts
fets <- function(y, h) {
forecast(ets(y), h = h)
}
# Apply tsCV() for both ETS and seasonal naive to calculate forecast errors
e1 <- tsCV(cement, fets, h = 4)
e2 <- tsCV(cement, snaive, h = 4)
# Compute MSE of resulting errors (watch out for missing values)
mean(e1^2, na.rm = TRUE)
mean(e2^2, na.rm = TRUE)
# Copy the best forecast MSE
bestmse <- 0.03046892
View(cement)
data(cement)
View(cement)
data(qcement)
## NOT WORKING, DIFFERENT CEMENT DATA REQUIRED
data(qcement)
# Function to return ETS forecasts
fets <- function(y, h) {
forecast(ets(y), h = h)
}
# Apply tsCV() for both ETS and seasonal naive to calculate forecast errors
e1 <- tsCV(qcement, fets, h = 4)
e2 <- tsCV(qcement, snaive, h = 4)
# Compute MSE of resulting errors (watch out for missing values)
mean(e1^2, na.rm = TRUE)
mean(e2^2, na.rm = TRUE)
# Copy the best forecast MSE
bestmse <- 0.03046892
data("qcement")
plot(qcement)
ets(qcement)
data("usmelec")
autoplot(usmelec) + xlab ("Year")+ ylab("") + ggtitle("US montly net electricity generation")
autoplot(usmelec) + xlab ("Year")+ ylab("") + ggtitle("US montly net electricity generation")
autoplot(usmelec^0.5) + xlab ("Year")+ ylab("") + ggtitle("US montly net electricity generation")
autoplot(log(usmelec)) + xlab ("Year")+ ylab("") + ggtitle("US montly net electricity generation")
autoplot(-1/usmelec) + xlab ("Year")+ ylab("") + ggtitle("US montly net electricity generation")
BoxCox.lambda(usmelec)
BoxCox.lambda(usmelec) ## choose lambda -0.477
usmelec %>% ets(lambda = -0.57) %>%
forecast(h=60) %>%
autoplot()
#
## Box-Cox transformations for time series
#
data(a10)
# Plot the series
autoplot(a10)
# Try four values of lambda in Box-Cox transformations
a10 %>% BoxCox(lambda =0.0) %>% autoplot()
a10 %>% BoxCox(lambda =0.1) %>% autoplot()
a10 %>% BoxCox(lambda =0.2) %>% autoplot()
a10 %>% BoxCox(lambda =0.3) %>% autoplot()
# Compare with BoxCox.lambda()
BoxCox.lambda(a10)
data("wmurders")
# Plot the US female murder rate
autoplot(wmurders)
# Plot the differenced murder rate
autoplot(diff(wmurders))
# Plot the ACF of the differenced murder rate
ggAcf(diff(wmurders))
data("h02")
# Plot the data
autoplot(h02)
# Take logs and seasonal differences of h02
difflogh02 <- diff(log(h02), lag = 12)
# Plot difflogh02
autoplot(difflogh02)
# Take another difference and plot
ddifflogh02 <- diff(difflogh02)
autoplot(ddifflogh02)
# Plot ACF of ddifflogh02
ggAcf(ddifflogh02)
autoplot(usnetelec)
fit <- auto.arima(usnetelec)
summary(fit)
fit %>% forecast() %>% autoplot()
# Fit an automatic ARIMA model to the austa series
fit <- auto.arima(austa)
# Check that the residuals look like white noise
checkresiduals(fit)
residualsok <- TRUE
# Summarize the model
summary(fit)
# Find the AICc value and the number of differences used
AICc <- -14.46
d <- 1
# Plot forecasts of fit
fit %>% forecast(h = 10) %>% autoplot()
# Plot forecasts from an ARIMA(0,1,1) model with no drift
austa %>% Arima(order = c(0, 1, 1), include.constant = FALSE) %>%
forecast() %>% autoplot()
# Plot forecasts from an ARIMA(2,1,3) model with drift
austa %>% Arima(order = c(2,1,3),include.constant = TRUE) %>% forecast() %>% autoplot()
# Plot forecasts from an ARIMA(0,0,1) model with a constant
austa %>% Arima(order = c(0,0,1),include.constant = TRUE) %>% forecast() %>% autoplot()
# Plot forecasts from an ARIMA(0,2,1) model with no constant
austa %>% Arima(order = c(0,2,1),include.constant = FALSE) %>% forecast() %>% autoplot()
data("debitcards") ## Iceland debit cards useage
autoplot(debitcards) + xlab("Year") + ylab("millions ISK")+
ggtitle("Retail debit card usage in Iceland")
fit <-auto.arima(debitcards,lambda = 0) ## box-cox lambda = 0 = log transform
fit_seasonal <-auto.arima(debitcards,lambda = 0) ## box-cox lambda = 0 = log transform
fit_Seasonal
fit_seasonal
fit_seasonal %>% forecast(=36) %>%
autoplot() + xlab("Year")
fit_seasonal %>% forecast(h=36) %>%
autoplot() + xlab("Year")
# Find an ARIMA model for euretail
fit1 <- auto.arima(euretail)
# Don't use a stepwise search
fit2 <- auto.arima(euretail, stepwise = FALSE)
# AICc of better model
AICc <- 68.39
# Compute 2-year forecasts from better model
fit2 %>% forecast(h = 8) %>% autoplot()
fit2
fit1
# Use 20 years of the qcement data beginning in 1988
train <- window(qcement, start = 1988, end = c(2007,4))
# Fit an ARIMA and an ETS model to the training data
fit1 <- auto.arima(train)
fit2 <- ets(train)
# Check that both models have white noise residuals
checkresiduals(fit1)
checkresiduals(fit2)
# Produce forecasts for each model
fc1 <- forecast(fit1, h = 25)
fc2 <- forecast(fit2, h = 25)
# Use accuracy() to find better model based on RMSE
accuracy(fc1, qcement)
accuracy(fc2, qcement)
bettermodel <- fit2
#
## Dynamic regression
#
data("uschange")
#plot us personal consumption and income
autoplot(uschange[,1:2], facets = TRUE) + xlab("Year")
data("uschange")
#plot us personal consumption and income
autoplot(uschange[,1:2], facets = TRUE) + xlab("Year")
## relationship between income and consumption
ggplot(aes(x = Income, y = Consumption),
data = as.data.frame(uschange)) +
geom_point() +
ggtitle("Quarterly changes in US consumption and personal income")
fit <- auto.arima(uschange[,"Consumption"],
xreg = uschange[,"Income"])\
fit
## Fitting dynamic regression, add xreg argument
fit <- auto.arima(uschange[,"Consumption"],
xreg = uschange[,"Income"])
fit
checkresiduals(fit)
autoplot(fcast) + ylab("Percentage Change")
fcast <- forecast(fit, xreg = rep(0.8,8)) ## assumefuture income change by 0.8 per quarter for the next 8 quarter
autoplot(fcast) + ylab("Percentage Change")
data(advert)
data(advert,package = fma)
install.packages(fma)
install.packages("fma")
install.packages("fma")
library(fma)
data(advert)
data(advert,package = 'fma')
library(fpp2)
data(cafe)
library(fpp2)
library(fpp)
data(cafe)
library(fpp2)
library(fpp)
data(cafe)
fit <- auto.arima(cafe,xreg = fourier(cafe, K=1),
seasonal = FALSE,## set seasonal error = false,arima error - non-seasonal
lambda = 0)  ## box-cox transformation with lambda = 0
fit %>% forecast(xreg = fourier(cafe, K=1, h =24)) %>%
autoplot() +ylim(1.6,5.1)
autoplot(fit)
fit <- auto.arima(cafe,xreg = fourier(cafe, K=3),
seasonal = FALSE,## set seasonal error = false,arima error - non-seasonal
lambda = 0)  ## box-cox transformation with lambda = 0
fit %>% forecast(xreg = fourier(cafe, K=3, h =24)) %>%
autoplot() +ylim(1.6,5.1)
data(cafe)
fit <- auto.arima(cafe,xreg = fourier(cafe, K=3),
seasonal = FALSE,## set seasonal error = false,arima error - non-seasonal
lambda = 0)  ## box-cox transformation with lambda = 0
fit %>% forecast(xreg = fourier(cafe, K=3, h =24)) %>%
autoplot() +ylim(1.6,5.1)
cafe
data(cafe)
fit <- auto.arima(cafe,xreg = fourier(cafe, K=1),
seasonal = FALSE,## set seasonal error = false,arima error - non-seasonal
lambda = 0)  ## box-cox transformation with lambda = 0
fit %>% forecast(xreg = fourier(cafe, K=1, h =24)) %>%
autoplot() +ylim(1.6,5.1)
#
## Forecast weekly data
#
# Set up harmonic regressors of order 13
harmonics <- fourier(gasoline, K = 13)
# Fit regression model with ARIMA errors
fit <- auto.arima(gasoline, xreg = harmonics, seasonal = FALSE)
# Forecasts next 3 years
newharmonics <- fourier(gasoline, K = 13, h = 156)
fc <- forecast(fit, xreg = newharmonics)
# Plot forecasts fc
autoplot(fc)
data(taylor)
#
##Harmonic regression for multiple seasonality
#
data(taylor)#half-hourly electricity demand in England
## 2 seasonality 48(daily seasonality) and 3*48 = 336 (weekly seasonality)
# Fit a harmonic regression using order 10 for each type of seasonality
fit <- tslm(taylor ~ fourier(taylor, K = c(10, 10)))
# Forecast 20 working days ahead
fc <- forecast(fit, newdata = data.frame(fourier(, K = c(10, 10), h = 20*48)))
# Plot the forecasts
autoplot(fc)
# Forecast 20 working days ahead
fc <- forecast(fit, newdata = data.frame(fourier(taylor, K = c(10, 10), h = 20*48)))
# Plot the forecasts
autoplot(fc)
# Plot the calls data
autoplot(calls)
# Set up the xreg matrix
xreg <- fourier(calls, K = c(10,0))
# Fit a dynamic regression model
fit <- auto.arima(calls, xreg = xreg, seasonal = FALSE, stationary = TRUE)
# Check the residuals
checkresiduals(fit)
# Plot forecasts for 10 working days ahead
fc <- forecast(fit, xreg =  fourier(calls, c(10, 0), h = 1690))
autoplot(fc)
data("gasoline")
gasoline %>% tbats() %>% forecast() %>%
autoplot() +
xlab("Year") + ylab("thousands barrels per day")
# Plot the gas data
autoplot(gas)
# Fit a TBATS model to the gas data
fit <- tbats(gas)
# Forecast the series for the next 5 years
fc <- forecast(fit,h=60)
# Plot the forecasts
autoplot(fc)
# Record the Box-Cox parameter and the order of the Fourier terms
lambda <- 0.082
K <- 5
setwd("C:/Users/dell/Desktop/DataCamp-Practice/Time Series in R/Visualising Time Series in R")
data <-read.csv("data.csv")
data <-read.csv("dataset.csv")
# Plot yahoo data and add title
plot(data$yahoo,main ="yahoo")
data
